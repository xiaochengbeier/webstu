# 数据结构与算法之选择排序
【小城贝尔】

两层循环内外套，中间指针极值到。

指针初始外层套，内层初始同值到。

挨个比较判断套，符合条件切换到。

位置交换索引套，循环往复排序到。

还有优化指针套，如若不变性能到。

## 两层循环内外套，中间指针极值到。
   选择排序也是使用两层循环内外嵌套在两层循环中间定义一个变量
   保存每次找到的那个最大值或者最小值的索引
## 指针初始外层套，内层初始同值到。
    每轮比较索引的初始化值是外层循环的变量
    内层循环开始值也是外层变量
    因为我们每次都将找到的那个 极值 放到数组的最前端
## 挨个比较判断套，符合条件切换到。
    根据条件判断如果符合条件就改变索引值
## 位置交换索引套，循环往复排序到。
    内层每次循环完毕之后就会找到一个 极值 的索引
    然后将这个值放到数组的最前端
## 还有优化指针套，如若不变性能到。
    优化是判断索引值是否改变 如果说索引值没有改变那么就已经排序完毕无需在做
    其他判断直接结束方法运行
```JS
          let arr = [99, 98, 92, 5, 100];
        let count = 0;

        function choose(arr) {
            if (arr == null || arr.length == 0) {
                return;
            }
            for (let j = 0; j < arr.length; j++) {
                // *******两层循环内外套，中间指针极值到。*******
                let extreme = j;
                // *******指针初始外层套，内层初始同值到。*******
                for (let i = j; i < arr.length; i++) {
                    if (arr[i] < arr[extreme]) {
                        // *******挨个比较判断套，符合条件切换到。*******
                        extreme = i;
                    }
                    console.log("比较了 === 》" + (++count) + "次");
                }
                //优化 如果 extreme没有变表示排序完毕
                // 优化      比较了 === 》12次
                // 没有优化  比较了 === 》15次
                // *******还有优化指针套，如若不变性能到。*******
                if (extreme == j) {
                    return;
                }
                // *******位置交换索引套，循环往复排序到。*******

                let temp = arr[extreme];
                arr[extreme] = arr[j];
                arr[j] = temp;
            }
        }
        choose(arr);
        console.log(arr);
```