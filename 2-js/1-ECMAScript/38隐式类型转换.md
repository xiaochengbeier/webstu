# js隐式类型转换
【小城贝尔】

加加减减和正负，计算余数和乘除。

判断一值并非数，底层调用Number住。

设计加号最特殊，拼接字符最牢固。

逻辑判断运算符，调用布尔转换读。

两个字符比大小，内部对照字吗表。

判断相等不转换，绝对符号在判断。
## 隐式转换优先级，数字布尔字符啼。
    隐式转换到的时候如果有数子那么会首先把另一边转换成数字
    接着优先级就是布尔值 
    比如说 
    2 == true; 答案是 false 因为 数字优先级高会先将 true转换成 1 而不是将 2 转换成true
    "2" == true; 答案是 true 因为 字符布尔值 布尔值优先级高会将 "2" 转换成布尔值
## 字符数字有正负，计算余数和乘除。
        var a = +"3";
        console.log(a); //数字 3
        var b = "5" - 3;
        console.log(b); //数字 2
        var c = 3 * "3";
        console.log(c); //数字 9
        var d = "4" / 2;
        console.log(d); //数字 2
        var e = 10 % "3";
        console.log(e); //数字 1     
## 判断一值并非数，底层调用Number住。
       isNaN(); 底层调用的是 Number();
## 设计加号最特殊，拼接字符最牢固。
        + 如果两边有字符的话那么  便是字符串拼接
## 逻辑判断运算符，调用布尔转换读。
        当进行逻辑判断的时候会隐式调用Boolean（）
## 两个字符比大小，内部对照字吗表。
        如果两个字符串比交大校是对照字码表的大小的
        "23" > "3";  ---》 false
        "23" > 3;---》 true 这种情况会 Number()隐式调用
## 空值加上未定义,隐式转换等莫去。
   null 和 undefined 在进行 == 判断的时候不会进行隐式转换 仅仅是在 == 号判断的时候不转换
   其他情况依然会转换
## 判断相等不转换，绝对符号在判断。
        ==  会转换
        ===绝对等于  !== 绝对不等于  不会隐式转换
## 引用类型奔字符，每次调用方法毒。
    如果是引用类型的数转换的话 会调用toString()方法
    巧妙的运用toString();方法可以进行一个隐式迭代器
    如
    <script>
        var a = {
                i: 1,
                toString: function() {
                return ++this.i;
                }
        }
    </script>
     每进行隐式转换一次就会将 i增加一个值；