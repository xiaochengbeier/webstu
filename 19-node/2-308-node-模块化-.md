# node模块化

【小城贝尔】

出入模块路先今，相对解析绝对定。

相对点杠自我进，直接名称包确定。

确信之前内置进，缓存第一效率定。

包中名称文件进，扩展名称先后定。

不是文件夹路进，在寻配置入口定。

入口不在索引进，回溯层级全局定。

模块导出函数进，电话呼叫指向定。

传入参数依次进，文件名称导入定。

最终模块导出进，返回对象即确定。

浏览导出实验进，文件命名配置定。

二者混用错误进，切记区分规则定。

## 出入模块路先进，相对解析绝对定。
   导入某个模块首先要分析其路径 
   如果是相对路径最终还是会被解析成绝对路径
## 相对点杠自我进，直接名称包确定。
   如果相对路径是 require("./xx/xx"); 这种形式 那么是会在当前目录下寻找我们自己定义的文件
   如果直接是 require("xx"); 那么就直接到 mode_modules中寻找
## 确信之前内置进，缓存第一效率定。
   在  mode_modules中寻找之前需要先看一下是不是内置模块
   在 看内置模块之前需要检查是否在缓存中存在如果缓存中有就直接从缓存中拿取
## 包中名称文件进，扩展名称先后定。
   在 mode_modules中首先找 xx.js xx.json xx.node xx.mjs 的文件
## 不是文件夹路进，在寻配置入口定。
   如果不是文件那么将 xx 作为文件夹的名字进入查看配置文件package.json 文件
   中的 mian 配置的入口文件 
## 入口不在索引进，回溯层级全局定。
  如果 main没有配置那么看看当前文件夹是否有 index.xx 
  如果还是没有那么就回溯到父级 mode_modules 一直到
  全局 mode_modules没找到就报错 
## 模块导出函数进，电话呼叫指向定。
   当使用 require导入一个模块的时候会将被导入的模块放在一个函数环境执行
   使用call绑定其this
## 传入参数依次进，文件名称导入定。
   然后依次传入参数 
## 最终模块导出进，返回对象即确定。
   比如 text 就是这个函数环境
   text.call(module.exports,module,exports,__dirname,__filname,require);
## 浏览导出实验进，文件命名配置定。
   在最新的nodejs中是可以使用 es6的导入导出方式的
   使用 xx.mjs 或者是在配置文件中配置 mode:
```js
    // package.json
    {
    "type": "module"
    }
```
## 二者混用错误进，切记区分规则定。
   此种方式还处于试验阶段 因为二者执行的环境不同是不可以混合使用的
  【ecma导出】
```js
    export default {
      name:"小城贝尔",
      age:22
    }
```
  【ecma导入】
```js
   import me from "./ecma.mjs"
   console.log(me);
```
```js

```
```js
    //  执行指令
     node --experimental-specifier-resolution=node index 
```