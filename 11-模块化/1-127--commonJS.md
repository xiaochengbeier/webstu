# commonJS
【小城贝尔】
前端脚本浏览器，发展历程艰辛记。

突破运行引擎器，前后并行生态记。

安装后台环境器，服务接口标准记。

引入导出模块器，关键字符隐藏记。

需要模块导入器，相对路径严格记。

导入先寻缓存器，如已运行即标记。

导入模块运行器，函数环境保护记。

内部模块导出器，同名变量赋值记。

返回模块导出器，同名变量指向记。

# 前端脚本浏览器，发展历程艰辛记。
    JavaScript发展从当初的只能在浏览器运行发展到现在的阶段
    历尽艰险
# 突破运行引擎器，前后并行生态记。
    js执行速率的突破的标志性事件 2008年 v8 引擎
    最终在各种条件下引用形成大前端生态
# 安装后台环境器，服务接口标准记。
    安装 一个 node.js 的运行环境 其中包含 nodeAPI 
    就可以像其他后端语言一样直接在机器上运行
# 引入导出模块器，关键字符隐藏记。
    commonJS就是作用域 node环境的模块化标准
    使用 exports【导出】 和 require【导入】这两个关键字
    凡是出现这两关键字的文件就会被认为是一个模块里边的变量方法就对于全局作用域隐藏
    无法直接访问
# 需要模块导入器，相对路径严格记。
    require("./xx.js"); 使用相对路径导入 对应的模块导出的数据 一定是严格的相对路径 ./ 必须存在
# 导入先寻缓存器，如已运行即标记。
      require("./xx.js"); 首先查找缓存 如果缓存中有那么直接从缓存中获取 没有那么执行 xx.js文件
      得到xx.js文件导出的数据 也就是说 xx.js 只会执行一遍
# 导入模块运行器，函数环境保护记。
    导入模块的 xx.js 执行会被放到一个函数环境执行这样就避免了全局变量的污染
# 内部模块导出器，同名变量赋值记。
    对于导出模块的exports关键字内部执行原理如下
    function(module【系统注入的参数】){// xx.js执行的函数环境
        module.exports = {};
        let exports =  module.exports;
        ....
        ...
        return  module.exports;
    }
# 返回模块导出器，同名变量指向记。
    注意最终返回的是  module.exports
    不管其他条件咋变