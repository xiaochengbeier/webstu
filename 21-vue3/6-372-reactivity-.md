# reactivity

【小城贝尔】

响应数据抽模块，不与环境解藕在。

# -------reactive------------
获得响应代理块，执行方法导入在。

方法执行参数块，要求平面对象在。


# -------readonly------------
获得只读对象块，操作方法刚健在。

参数平面对象块，也可代理参数在。


# ------------ref------------
创建引用响应块，内外取值区别在。

数据类型基本块，代理只读参数在。


# -------computed------------
计算属性缓存块，取值执行时机在。

# --watchEffect----watch-----
观察影响方法块，执行时机开始在。

自动依赖收集块，对比观察手动在。

执行队列微模块，返回取消方法在。

# -----------类型判断--------
判断类型方法块，代理引用只读在。

# -----------类型转换--------
类型转换方法块，保持代理响应在。

注意结构点点块，全部转换本领在。

响应数据抽模块，不与环境解藕在。

# -------reactive------------
获得响应代理块，执行方法导入在。

方法执行参数块，要求平面对象在。

# -------readonly------------
获得只读对象块，操作方法刚健在。

参数平面对象块，也可代理参数在。

# ------------ref------------
创建引用响应块，内外取值区别在。

数据类型基本块，代理只读参数在。

# -------computed------------
计算属性缓存块，取值执行时机在。

# --watchEffect----watch-----
观察影响方法块，执行时机开始在。

自动依赖收集块，对比观察手动在。

执行队列微模块，返回取消方法在。

# -----------类型判断--------
判断类型方法块，代理引用只读在。

# -----------类型转换--------
类型转换方法块，保持代理响应在。

注意结构点点块，全部转换本领在。


# 响应数据抽模块，不与环境解藕在。
    vue3将响应式数据单独作为一个模块
    脱离环境依赖
# 获得响应代理块，执行方法导入在。
# 方法执行参数块，要求平面对象在。
    reactive({平面对象}) 获得一个代理对象参数要求是平面对象
# -------readonly------------
# 获得只读对象块，操作方法刚健在。
# 参数平面对象块，也可代理参数在。
    readonly(平面对象或者是代理对象); 获得一个属性为只读的对象
# ------------ref------------
# 创建引用响应块，内外取值区别在。
# 数据类型基本块，代理只读参数在。
    ref(任何数据类型均可); 获得一个 ref 对象 其value值是一个代理对象
    ref的诞生主要是解决 reactive方法不能代理基本类型的数据
    【参数是基本类型】
    当ref的参数是 一个基本类的时候将这个数据包裹为一个对象然后
    通过reactive 变成代理赋值给这个返回对象的value值
    【参数是代理类型】
    直接将这个代理数据赋值给 value
# -------computed------------
# 计算属性缓存块，取值执行时机在。
    computed({
        get(){

        },
        set(){

        }
    })
    获得一个 ref对象 只有在 value 取值的时候该函数才会根据情况
    判断是否执行 如果说不取值 那么永远都不会执行
    如果有缓存存在也不会执行
# --watchEffect----watch-----
# 观察影响方法块，执行时机开始在。
    watchEffect(()=>{
        // 刚开始会立马执行一次 然后当其依赖的属性改变之后异步执行
        // 执行函数会放到微队列
    })
# 自动依赖收集块，对比观察手动在。
    该方法的依赖是自动收集的并且如果说依赖的是某个对象 但是改变的是其子属性那么该方法观察不到
    对比 watch(监听对象,(newValue,oldValue)=>{},{immediate:true});
    immediate: 表示初始化的时候也执行和 vue2 一样
```js
     watch(监听对象,(newValue,oldValue)=>{},{immediate:true});
    【reactive对象指定监听属性】
    watch(()=>obj.prop,()=>{});
    【ref对象指定监听属性】
    watch(xxRef,()=>{})
    【监听多个数据】
    watch([a,b,c,d],(news,olds)=>{})
```
# 执行队列微模块，返回取消方法在。
    不管是watchEffect还是得watch其执行函数都是在微队列
    返回一个方法其作用是取消监听
# -----------类型判断--------
# 判断类型方法块，代理引用只读在。
    isProxy()         是否是代理
    isReactive()      是否是rective对象
    isReadonly()      是否是readonly对象
    isRef()           是否是ref对象
# -----------类型转换--------
# 类型转换方法块，保持代理响应在。
    unRef(); 等同于 isRef(objRef)?objRef.value: objRef;
    toRef(); 将一个代理对象的属性值转换成ref对象
    toRefs();  将一个代理对象转换成一个ref对象
# 注意结构点点块，全部转换本领在。
    当我们使用展开参数的时候很容易丢失响应式
    比如说 ... reactivObj 
    一个对象展开了当前就相当于吧代理干掉了
    所以当我们不确定一个个对象是 reactive类型
    还是ref类型 最好统统使用 toRefs 包裹 这样
    就比较安全啦