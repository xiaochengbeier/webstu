# webpack编译原理
【小城贝尔】
配置文件初始化，组装全局配置挂。

入口路径模块化，判断资源列表挂。

如不存在即分化，解析语法抽象挂。

设置加载自由化，解析语法前边挂。

解析依赖存储化，替换依赖命名挂。

存储解析键值化，模块路径查找挂。

再次循环依赖化，完毕资源列表挂。

绑定完毕文件化，此时标志哈希挂。

解析模块并行化，入口文件可多挂。

资源综合列表化，还有哈希针对挂。

最后输出文件化，编译流程简析挂。

## 配置文件初始化，组装全局配置挂。
    webpack工作流程简析 
    1.【初始化部分】当执行webpack命令的时候首先运行根目录想webpack.config.js文件读取配置信息
      然后在融合一些默认配置信息通过 yargs这个插件将这些配置信息封装成一个全局配置对象
## 入口路径模块化，判断资源列表挂。
    2.【编译部分】
    --1--创建一个chunk 并且这个chunk 对应一个或者多个入口文件路径
         并且这个chunk有自己的名字默认是main 和 id如果是开发环境和名字相同如果是生产环境就是数组
## 如不存在即分化，解析语法抽象挂。
    --2--判断chunk对应的路径是否已经被解析并且在chunkassets（资源列表中已经存在） 若果存在就不解析
         如果不存在那么就加在这个文件解析其内容  
## 设置加载自由化，解析语法前边挂。
     --3--根据配置文件中配置的loader对解析的文件字符串进一步操作如果没有配置那么就走默认的逻辑
     --4--文件内容解析完毕之后进行AST 抽象语法树分析就是分析src目录下那些文件中的内容 
## 解析依赖存储化，替换依赖命名挂。
    --5--将解析到的依赖路径存储到一个数组中
    --6--替换依赖的那些方法名 比如将 模块导入 require替换为 __webpack_require__
## 存储解析键值化，模块路径查找挂。
    --7--将文件解析的字符串以键值对的形式保存到chunkassets资源列表中 这个资源列表对应一个 chunkhash 用      于检测内容的唯一性
## 再次循环依赖化，完毕资源列表挂。
    --8--然后循环解析保存的依赖路径对应的文件直到将所有的文件全部解析完毕都保存到资源列表中
## 绑定完毕文件化，此时标志哈希挂。
    bound绑定就是将入口文件以及其依赖多个文件绑定到一起对应一个chunkhash 
    就是对--7--的另一种说法
## 解析模块并行化，入口文件可多挂。
    1-对于chunk也是可以指定多个的也就是说可以并行同时编译两个文件同时编译结果也是两个文件

    2-对于chunk的入口路径可以指定多个如果指定多个那么就是将多个入口文件解析获得依赖模块最终
    形成一个资源列表即只会形成一个编译后的文件
    对于这些配置位置在 webpack.config.js 中的
    entry{
        chunkName1:[入口文件路径1，入口文件路径2，。。]，
        chunkName2："入口文件路径",
    }
## 资源综合列表化，还有哈希针对挂。
    在解析完毕所所有的资源列表还有一个总的 hash 用来标志中的资源列表
## 最后输出文件化，编译流程简析挂。
    3【输出】 将资源列表中的各个模块信息根据输出配置生成响应文件
     对于这些配置位置在 webpack.config.js 中的
    output{
       path:"输出的文件存存储路径 默认是dist"
       filename:"文件名默认是mian当然也可使用解析过程中那些哈希名称使用方法[name][hash][id][chunkhash]"
    }