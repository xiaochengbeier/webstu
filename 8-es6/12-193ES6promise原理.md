# promise原理
【小城贝尔】

事件循环明确先，承诺方法微队间。

状态规定未决先，拒绝处理一瞬间。

达到已决状态先，无法逆转悔恨间。

然后触发微队先，高效控制回调间。

## 事件循环明确先，承诺方法微队间。
    学习promis之前需要明确几个概念
    事件循环
        1，js执行队列
           由于js是单线程的所以当一个js文件加载到js引擎开始执行 首先会在执行栈最低端创建一个全局AO 对象
           然后按照代码顺序由上到下开始执行js代码 每遇到一个函数需要执行性那么就 创建这个函数的Ao 压入栈顶 然后执行完毕 AO消失

           当遇到 事件监听  事件监听(如 setInterval..) 网络请求(如：ajax) 浏览器会开启一个线程监听这些
           状态的改变 比如说 事件有没有被触发  时间监听时间到了没  ajax请求响应状态等等..
           {---注意--- js虽然是单线程 但是浏览器是多线程所以可异步完成这些操作}

           如果说js执行栈还没有执行完 就有事件被触发了需要执行绑定的函数增么办呢 这个时候队列就产生了
           浏览器会将需要执行的函数放入事件队列中然后等到 js执行栈中执行完毕也就是所全局Ao对象都没了
           {--注意-- 一定是执行栈中空空如也 连个毛都没得的时候  就从事件队列中拿出需要执行的函数执行}
        2，事件队列
            宏队列：执行顺序 js执行栈完毕 微队列执行完毕 可以包含 网络请求   事件监听  时间监听等函数
            微队列：执行顺序 js执行栈完毕  可以包含 promise MutationObserver 有关函数
    事件循环指的就是 从js执行栈 到浏览器异步监听 再到 执行队列 然后又回到 js执行栈这一个大圈圈
## 状态规定未决先，拒绝处理一瞬间。
    promise 的两个状态 
    settled 未决状态
    unsettled   已决状态
                                                                                        
                    |----resolve(data 可以传输数据)---->   resolved(已决状态);  ---> thenable
    pending(未决状态)
                    |----reject(data 可以传输数据))---->    rejected(已决状态); ---> catchable

    resolved:表示已经处理 符合正常业务逻辑    thenable 表示此状态后续处理函数
    rejected:表示发生异常 比如说程序报错 断网等意外情况   catchable 表示此状态后续处理函数
## 达到已决状态先，无法逆转悔恨间。
   由 未决状态发展到已决状态这个过程是不可逆转的
## 然后触发微队先，高效控制回调间。
    promise对应的回调函数是加入到微队列中的所以执行顺序比 宏队列先
    也就是说比setInterval(); setTimeOut(); 事件执行函数 ajax 先

    promise的作用就是将回调变为可控更好的解决地狱回调之类的问题