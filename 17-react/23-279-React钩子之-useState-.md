# React钩子之useState

【小城贝尔】

引入状态函数中，默认设值参数空。

切记坐落判断中，常规使用首行空。

状态操作数组中，解构赋值语法空。

状态列表挂载中，下次更新默认空。

设置调用覆盖中，上次状态值清空。

是否更新校验中，状态未变渲染空。

对于设置事件中，异步处理优化空。

传入函数括号中，线性排列执行空。

## 引入状态函数中，默认设值参数空。
   useState(默认值)是为了解决函数组件中没有属于自己的状态而诞生的
   对于默认值可以为空
## 切记坐落判断中，常规使用首行空。
   对于所有的钩子函数都是不能放在判断条件中的
   必须让组件一开始就明确的知道组件中有哪些钩子一般
   直接放在首行
## 状态操作数组中，解构赋值语法空。
   使用useState后会返回一个数组
```js
    let [n,setN] = useState(1);
```
## 状态列表挂载中，下次更新默认空。
   对于这些钩子都会挂载到该组建的钩子列表中
   第二次执行该组件其默认值就会被忽略
## 设置调用覆盖中，上次状态值清空。
   当我们调用 setN 改变状态的时候不会保留原先的转态数据
   而是全部覆盖 区别于 类组件 setState
## 是否更新校验中，状态未变渲染空。
   对于函数组件会自动校验状态是否改变如果说状态没有改变并不会触发该组件跟新
## 对于设置事件中，异步处理优化空。
   如果说设置状态函数是在html异步函数中调用
   比如说是 onClick 那么是异步的操作多次 render只会执行一次
## 传入函数括号中，线性排列执行空。
   对于异步设置转态处理可以将setN();中的值改为回调函数这样得到的状态便是
   按照线性序列执行的值
```js
    export default function UseStateTest(){
    // 报错 Hook不能放在条件判断中
    // if(true){
    //     let [c,setC] = useState(2);
    // }
    // 设置状态默认值1
    let [n,setN] = useState(666);
    console.log("我被调用了");
    return (<>
        <p>useState--n-->{n}</p>
        <button onClick={()=>{
            //设置状态会将状态值完全覆盖
            setN(++n);
        }}>+</button>

        <button onClick={()=>{
            //设置状态会将状态值完全覆盖
            setN(666);
        }} >调用设置状态但是值不变那么不会更新</button>
    </>);
}

```
   